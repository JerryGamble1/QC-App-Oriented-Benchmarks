{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### QED-C Prototype Benchmarks - Qiskit Version - with Algorithmix Qubits\n",
    "The notebook contains a suite of prototype application benchmarks for the IBM Qiskit API, along with the volumetric and the algorithmic qubit (AQ) measurement. \n",
    "Configure and run the cell below with the desired execution settings.\n",
    "Then execute the remaining cells, each containing one prototype benchmark program.\n",
    "\n",
    "Algorithmic qubits, #AQ = N, can be defined as a side of the largest box of width N and $N^2$ CX gates that can be drawn on the volumetric background, such that every circuit within this box meets the success criteria. In the new #AQ definition, only the number of CX gates in the circuit are tracked as single qubit gates are more accurate in most quantum computer hardware. The success probability of each circuit run on the quantum computer is measured by the Hellinger fidelity computed using the output probability distribution against the ideal output probability distribution. The circuit passes if the measured fidelity is greater than the threshold, which is 0.37. For more details, please visit: https://ionq.com/posts/february-23-2022-algorithmic-qubits"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "min_qubits=2\n",
    "max_qubits=8\n",
    "max_circuits=3\n",
    "num_shots=1000\n",
    "\n",
    "backend_id=\"qasm_simulator\"\n",
    "hub=\"ibm-q\"; group=\"open\"; project=\"main\"\n",
    "provider_backend = None\n",
    "exec_options = None\n",
    "\n",
    "# # *** If using IBMQ hardware, run this once to authenticate\n",
    "# from qiskit import IBMQ\n",
    "# IBMQ.save_account('YOUR_API_TOKEN_HERE')\n",
    "\n",
    "# # *** If you are part of an IBMQ group, set hub, group, and project name here\n",
    "# hub=\"YOUR_HUB_NAME\"\n",
    "# group=\"YOUR_GROUP_NAME\"\n",
    "# project=\"YOUR_PROJECT_NAME\"\n",
    "\n",
    "# # *** This example shows how to specify the backend using a known \"backend_id\"\n",
    "# # Use 'sabre' layout for IBM backends\n",
    "# exec_options = { \"optimization_level\":3, \"layout_method\":'sabre', \"routing_method\":'sabre' }\n",
    "# backend_id=\"ibmq_belem\"\n",
    "\n",
    "# # *** Here's an example of using a typical custom provider backend (e.g. AQT simulator)\n",
    "# import os\n",
    "# from qiskit_aqt_provider import AQTProvider\n",
    "# provider = AQTProvider(os.environ.get('AQT_ACCESS_KEY'))    # get your key from environment\n",
    "# provider_backend = provider.backends.aqt_qasm_simulator_noise_1\n",
    "# backend_id=\"aqt_qasm_simulator_noise_1\"\n",
    "\n",
    "# # An example using IonQ provider\n",
    "# from qiskit_ionq import IonQProvider\n",
    "# provider = IonQProvider()   # Be sure to set the QISKIT_IONQ_API_TOKEN environment variable\n",
    "# provider_backend = provider.get_backend(\"ionq_qpu\")\n",
    "# backend_id=\"ionq_qpu\"\n",
    "\n",
    "# # *** Use these lines when running on hardware backend, to limit use of resources\n",
    "# min_qubits=2\n",
    "# max_qubits=5\n",
    "# max_circuits=1\n",
    "# num_shots=100"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Quantum Fourier Transform - Method 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#%run quantum-fourier-transform/qiskit/qft_benchmark.py\n",
    "import sys\n",
    "sys.path.insert(1, \"quantum-fourier-transform/qiskit\")\n",
    "import qft_benchmark\n",
    "qft_benchmark.run(min_qubits=min_qubits, max_qubits=max_qubits, max_circuits=max_circuits, num_shots=num_shots,\n",
    "                method=1,\n",
    "                backend_id=backend_id, provider_backend=provider_backend,\n",
    "                hub=hub, group=group, project=project, exec_options=exec_options)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Phase Estimation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#%run phase-estimation/qiskit/pe_benchmark.py\n",
    "import sys\n",
    "sys.path.insert(1, \"phase-estimation/qiskit\")\n",
    "import pe_benchmark\n",
    "pe_benchmark.run(min_qubits=min_qubits, max_qubits=max_qubits, max_circuits=max_circuits, num_shots=num_shots,\n",
    "                backend_id=backend_id, provider_backend=provider_backend,\n",
    "                hub=hub, group=group, project=project, exec_options=exec_options)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Amplitude Estimation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#%run amplitude-estimation/qiskit/ae_benchmark.py\n",
    "import sys\n",
    "sys.path.insert(1, \"amplitude-estimation/qiskit\")\n",
    "import ae_benchmark\n",
    "ae_benchmark.run(min_qubits=min_qubits, max_qubits=max_qubits, max_circuits=max_circuits, num_shots=num_shots,\n",
    "                backend_id=backend_id, provider_backend=provider_backend,\n",
    "                hub=hub, group=group, project=project, exec_options=exec_options)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Monte Carlo"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#%run monte-carlo/qiskit/mc_benchmark.py\n",
    "import sys\n",
    "sys.path.insert(1, \"monte-carlo/qiskit\")\n",
    "import mc_benchmark\n",
    "mc_benchmark.run(min_qubits=min_qubits, max_qubits=max_qubits, max_circuits=max_circuits, num_shots=num_shots,\n",
    "                backend_id=backend_id, provider_backend=provider_backend,\n",
    "                hub=hub, group=group, project=project, exec_options=exec_options)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Difference between the Hellinger fidelity and the Polarization fidelity\n",
    "\n",
    "Note that there is a difference between Hellinger Fidelity and the \"Result Fidelity\", which is polarization fidelity,  especially in algorithms with output states that are not in the computatiobal basis (the output distribution does not concentrate on just one bitstring). In the current benchmark suite, such a difference is shown in the amplitude estimation and the Monte Carlo algorithms. This could be understand by looking at the definition of the Hellinger fidelity and the polarization fidelity. \n",
    "\n",
    "The Hellinger fidelity is defined as\n",
    "\\begin{equation}\n",
    "    F_s(P_{ideal}, P_{output})=\\left(\\sum_x{\\sqrt{P_{output}(x)P_{ideal}(x)}}\\right)^2\n",
    "\\end{equation}\n",
    "and the polarization fidelity is defined as\n",
    "\\begin{equation}\n",
    "    F(P_{ideal}, P_{output})=\\frac{F_s(P_{ideal}, P_{output})-F_s(P_{ideal}, P_{uni})}{1-F_s(P_{ideal}, P_{uni})}\n",
    "\\end{equation}\n",
    "in which $P_{uni}$ is the uniform distribution, and $P_{uni}(x)=1/2^n \\forall x$, in which $n$ is the total number of qubits being measured.  \n",
    "\n",
    "\n",
    "As one could see, the polarization fidelity is defined as to subtract the uniform distribution from the Hellinger fidelity, and normalize it so that it is between 0 and 1. It is an open research question about which fidelity measures the algorithm performance more accurately. As the number of qubit increases, $F_s(P_{ideal}, P_{uni})$ becomes exponentially small so that these two fidelities agree with each other in the large qubit number limit. With a small number of qubits, the Hellinger fidelity is usually higer than the polarization fidelity, especially for circuits whose output states are not in the computational basis. This could be understood by the following example. \n",
    "\n",
    "Consider a circuit with 2 qubits and the ideal distribution is {'01':1.0}. In this case, the ideal output state is in the computational basis (all population in one bitstring). When using a depolarization noise model with error rate of 25%, the output distribution becomes {'00':0.0625, '01':0.8125, '10':0.0625, '11':0.0625}, and then the Helliger fidelity and the polarization fidelity are the same\n",
    "\n",
    "\\begin{equation}\n",
    "    F_s=0.8125, F=0.8125\n",
    "\\end{equation}\n",
    "\n",
    "Then consider another circuit with 2 qubits and the ideal distribution is {'01':0.5, '10':0.5}, in which the output state is not in the computational basis (population spreads out to multiple bitstrings). When using a depolarization noise model with error rate of 25%, the output distribution becomes {'00':0.0625, '01':0.4375, '10':0.4375, '11':0.0625}, and then the Helliger fidelity and the polarization fidelity are\n",
    "\n",
    "\\begin{equation}\n",
    "    F_s=0.875, F=0.778\n",
    "\\end{equation}\n",
    "and in this case the Hellinger fidelity is higher than the polarization fidelity. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Hamiltonian Simulation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#%run hamiltonian-simulation/qiskit/hamiltonian_simulation_benchmark.py\n",
    "import sys\n",
    "sys.path.insert(1, \"hamiltonian-simulation/qiskit\")\n",
    "import hamiltonian_simulation_benchmark\n",
    "hamiltonian_simulation_benchmark.run(min_qubits=min_qubits, max_qubits=max_qubits,\n",
    "                max_circuits=max_circuits, num_shots=num_shots,\n",
    "                backend_id=backend_id, provider_backend=provider_backend,\n",
    "                hub=hub, group=group, project=project, exec_options=exec_options)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### VQE Ansatz - Method 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#%run vqe/qiskit/vqe_benchmark.py\n",
    "import sys\n",
    "sys.path.insert(1, \"vqe/qiskit\")\n",
    "import vqe_benchmark\n",
    "vqe_num_shots=4098\n",
    "vqe_benchmark.run(min_qubits=min_qubits, max_qubits=max_qubits, max_circuits=max_circuits, num_shots=vqe_num_shots,\n",
    "                method=1,\n",
    "                backend_id=backend_id, provider_backend=provider_backend,\n",
    "                hub=hub, group=group, project=project, exec_options=exec_options)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### All Applications - Algorithmic Qubits - Hellinger Fidelity"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import sys\n",
    "sys.path.insert(1, \"_common\")\n",
    "import metrics\n",
    "\n",
    "apps = [ \"Quantum Fourier Transform (1)\", \"Phase Estimation\", \"Amplitude Estimation\", \"Monte Carlo Sampling (2)\", \"VQE Simulation (1)\",  \"Hamiltonian Simulation\" ]\n",
    "\n",
    "metrics.plot_all_app_metrics(backend_id, do_all_plots=False, include_apps=apps)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### All Applications - Algorithmic Qubits - Normalized Result Fidelity"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import sys\n",
    "sys.path.insert(1, \"_common\")\n",
    "import metrics\n",
    "\n",
    "apps = [ \"Quantum Fourier Transform (1)\", \"Phase Estimation\", \"Amplitude Estimation\", \"Monte Carlo Sampling (2)\", \"VQE Simulation (1)\",  \"Hamiltonian Simulation\" ]\n",
    "\n",
    "metrics.plot_all_app_metrics(backend_id, do_all_plots=False, include_apps=apps, score_metric='avg_fidelities')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  },
  "vscode": {
   "interpreter": {
    "hash": "aee8b7b246df8f9039afb4144a1f6fd8d2ca17a180786b69acc140d282b71a49"
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
